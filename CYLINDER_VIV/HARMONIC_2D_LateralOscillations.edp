///
///
///
///		SCRIPT TO COMPUTE THE LINEAR FORCED PROBLEM OF AN OSCILLATING 2D BODY
/// 
///	Contributors: Ndong Fall, David Fabre, Diogo Sabino
///	Last modification: Diogo Sabino 18 April 2018
///
///	Programe fait dans repere relatif
include "SF_Geom.edp"; //Values for nondimensionalization
include "Macros_StabFem.edp";

cout << "_________________________________________________" << endl;		
cout << "| Objet en mouvement harmonique impose (selon U)|"<< endl;

////////////////////////////////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////////////////////////////
//	Mesh loading
	mesh th=readmesh(ffdatadir+"mesh.msh");

//	FEM space and variables definitions
	fespace Xh(th,P2);             ////// f.e. space for vel.
	fespace Mh(th,P1);            ////// f.e. space for pressure
	fespace XXMh(th,[P2,P2,P1]); ////// f.e. space for triplet [u,v,p]

	Mh pa ,pra;
	Xh uxa,uya;

	XXMh[UX,UY,PP];
		
	int Nt = UX[].n;
	real Re;
	string nomfile;
	int m;
	real OMEGA, OMEGAstep, OMEGAlast ;	
		
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////	        
// lecture du fichier champ de base (DEMI-ESPACE)	   
	XXMh [u0x,u0y,u0p];

	XXMh<complex> [vx,vy,qr],[ux,uy,up];
	XXMh [uxR,uyR,prR],[uxI,uyI,prI];

		{
 		ifstream cbin(ffdatadir+"BaseFlow.txt");
		 cbin >> u0x[];
		 cbin >> Re;	/*Reynolds number defined*/
		};

cout << "_________________________________________________" << endl;
cout << "| Lecture du champ de base      : Re = " << Re << "       |"<< endl;
cout << "|_______________________________________________|" << endl;
real nu=1./Re;

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
///création d'une structure de vecteur permettant de calculer les différents efforts
//Pressure Drag
varf DragP([vx,vy,q],[ux,uy,up])=TraineeP(u,"S");
	real[int] VdragPR(Nt);
	VdragPR(:) = DragP(0,XXMh);
	complex[int] VdragPC(Nt);   
	VdragPC(:) = DragP(0,XXMh);
//Viscous Drag
varf DragV([vx,vy,q],[ux,uy,up])=TraineeV(u,"S");
	real[int] VdragVR(Nt);
	VdragVR(:) = DragV(0,XXMh);
	complex[int] VdragVC(Nt);
	VdragVC(:) = DragV(0,XXMh);

//Lift
varf FyT([vx,vy,q],[ux,uy,up]) = Portance(u,"S");
	real[int] VFyT(Nt);
	VFyT(:) = FyT(0,XXMh);
	complex[int] VFyC(Nt);
	VFyC(:) = FyT(0,XXMh);
	
///Base flow Computation
	real DragP0 = VdragPR'*u0x[];
	real DragV0 = VdragVR'*u0x[];
	real DragT0= DragP0+DragV0;
	real Lift0 = VFyT'*u0y[];
///Display
	cout << "________________________________________________" << endl;
	cout << "| Drag Values:                    " << "              "<< endl;
	cout << "|      Pressure Base Flow Drag  : " << DragP0 << "       "<<endl;
	cout << "|      Viscous Base Flow Drag   : " << DragV0 << "      "<<endl;
	cout << "|      Total Base Flow Drag     : " << DragT0 << "      "<<endl;
	cout << "| Lift Value:                     " << "              "<< endl;
	cout << "|      Base Flow Lift:          : " << Lift0 << "      "<<endl;
	cout << "|_______________________________________________" << endl;

// Il faut faire les moments aussi, avec des macros
    // Moment	
	varf MomentT([vx,vy,q],[ux,uy,up])  = int1d(th,2)( 
	          2*x * (up*N.y -nu * ( (dx(uy)+dy(ux)) * N.x + 2*dy(uy) * N.y ) )
	         -2*y * (up*N.x -nu * ( 2*dx(ux) * N.x + (dx(uy)+dy(ux)) * N.y ) ) );
	real[int] VmomentT(Nt);
	VmomentT(:) = MomentT(0,XXMh);
	complex[int] VmomentC(Nt);
	VmomentC(:) = MomentT(0,XXMh);

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////	
// calcul du champ [ux,uy,up] correspondant a une vitesse harmonique

real U0=-1.; // vecteur d'osciallation latérale
// Oscillation laterale sans changement d'inclinaison  (alpha=-gamma,theta=0)
problem vfStokes([ux,uy,up],[vx,vy,qr]) =
	int2d(th)(
		- 1i*OMEGA*ux*vx
		- 1i*OMEGA*uy*vy // Terme 1: Temporel

		- Convbis(u,u0,v) // Terme 2

		+ up*divbis(v) //Terme 3: multiplie la pression

		-2*nu*(Dbis(u):Dbis(v)) //Terme 4

		-divbis(u)*qr // Terme 5: From continuous equation 

		+ up*qr*(1e-12) // ? Terme 6: C'est le terme de stabilisation ? on multiplie pour eps ?	
		)
	+int2d(th)(
		- 1i*OMEGA*vy*U0
		)

	+BoundaryconditionsForced(u,v,"A",U0);
	
	//+ on(2,ux=0)
	//+ on(2,uy=0)
	//+ on(1,4,ux=0,uy=-U0)          // 1= entree et 4 = paroi (3 = sortie)
	//+ on(6,ux=0,up=0);         		   // axe (mode antisym)

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
//Loop for different OMEGA values
//Save results in txt file

//This txt file is not created here, it's the matlab script that creates that file
//If this script is ran in terminal alone, creation of the file first is advised
//To create the file: uncomment if script.edp is ran in command line manually     
//ofstream resout(ffdataharmonicdir+"HARMONIC_2D_LateralOscillations_Re"+Re+".txt");
       
complex L2,M2;


//The matlab script automaticly puts a -1 in final echo statement
real inputvalue=-1;
//uncomment next line, when running manually
cout << "Omega values to comute (type -1 to exit): " << endl; 
cin >> inputvalue;
while (inputvalue !=-1)
{
	OMEGA=inputvalue;
	cout << "OMEGA = " << OMEGA << endl;
	vfStokes;

	L2 = VFyC'*ux[];
	M2 = VmomentC'*ux[];
	
	ofstream resout( ffdataharmonicdir+"HARMONIC_2D_LateralOscillations_Re"+Re+".txt",append);
	resout << OMEGA << " " << Re << " " << real(L2) << " " << imag(L2) << "  " << real(M2) << " " << imag(M2) <<endl;
	//NB: If output layout file is changed, the matlab treatement have to change
	//6 columns table: | OMEGA | Re | real(L2) | imag(L2)| real(M2)| imag(M2) |

cin >> inputvalue;
}


//END EDP FILE
	
