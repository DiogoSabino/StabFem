/// 
/// file Macros_StabFem.edp
///
/// This file contains the case-dependent Macros for boundary conditions and postprocessing output.
///
/// This file can be customized according to requirements but it must contain the following macros :
///
///
/// boundary conditions : 
/// macro BoundaryconditionsBaseFlow(du,u,v) 
/// macro BoundaryconditionsStability(u,v,symmetry)
///...
///
/// For post-processsing purposes :
/// macro SFWriteBaseFlow(filename,ux,uy,p,type,iter)
/// macro SFWriteMode(namefile,ux,uy,p,ev,shift,type,iter)
/// ...
///
/// NB: Never do in the middle of a macro a comment using //, it will end the macro. use /* */ instead

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
//Directories
string ffdatadir = "./WORK/";
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
string symmetryBaseFlow = "S"; // symmetry propery of base flow :; set "S" if domain is half domain and "N" if it is full domain
int bclat=4,bcinlet=1,bcoutflow=3,bcwall=2,bcaxis=6,bclatNOP=41;
real TGVCL = 1e25;
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
//Macros for forced problem   //////////////////////////////////////////////////////////////
macro divbis(u) (dx(u#x)+dy(u#y))// macro for divergence
//EOM
 
macro Convbis(ua,ub,v) ( 
              ( (ua#x*dx(ub#x)+ua#y*dy(ub#x))+(ub#x*dx(ua#x)+ub#y*dy(ua#x)))*v#x 
            + ((ua#x*dx(ub#y)+ua#y*dy(ub#y))+(ub#x*dx(ua#y)+ub#y*dy(ua#y)))*v#y 
                    ) // macro for mutual convection operator
//EOM

macro Dbis(u) [[dx(u#x), .5*(dx(u#y)+dy(u#x))], [.5*(dx(u#y)+dy(u#x)), dy(u#y)]] // macro for rate-of-deformation tensor
//EOM

macro Diffusionbis(nu,ux,uy,vx,vy)  (-nu*( dx(ux)*dx(vx)+dy(ux)*dy(vx)+dx(uy)*dx(vy)+dy(uy)*dy(vy))) // integration by parts of nu (v.Delta u)
//EOM
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
//Boundary Conditions
macro BoundaryconditionsBaseFlow(du,u,v)
	on(bcinlet,du#x=1.0-u#x,du#y=0.0)
	/* bc normally used at lateral boundaries are neumann (nothing to specify) */ 
	+ on(bclatNOP,du#x=0.0,du#y=0.0)  /*if you want to try no-penetration boundary(not optimal)*/
	+ on(bcwall,du#x=0.0,du#y=0.0) /*ajouter 21 22 23*/
	+ int1d(th,bcaxis)(du#x*v#x*1e30*(symmetryBaseFlow=="A")+du#y*v#y*1e30*(symmetryBaseFlow=="S"))       
     
//EOM


//EOM
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
////Used in Stab2D.edp when adapting mesh
macro BoundaryconditionsStability(u,v,symmetry)
	on(bcinlet,u#x=0.0,u#y=0.0)
	/* bc normally used at lateral boundaries are neumann (nothing to specify) */ 
	+ on(bclatNOP,u#y=0.0)  /* if you want to try no-penetration boundary (not optimal) */  
	+ on(bcwall,u#x=0.0,u#y=0.0) /*ajouter 21 22 23*/
        + int1d(th,bcaxis)(u#x*v#x*1e30*(symmetry=="A")+u#y*v#y*1e30*(symmetry=="S"))      
//EOM
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
macro BoundaryconditionsForced(u,v,U0,formulation)
	/*bclat=4,bcinlet=1,bcoutflow=3,bcwall=2,bcaxis=6*/
	/*next 2 lines equivalent to on(bcinlet,bclat,u#y=-U0)*/
	int1d(th,bcinlet,bclat)(TGVCL*(u#y*v#y) )
	+int1d(th,bcinlet,bclat)(TGVCL*(U0*v#y)*(formulation=="R") )
	
	/*next 2 lines equivalent to on(bcwall,u#x=0.0,u#y=0.0) */
	+int1d(th,bcwall)(u#y*v#y*TGVCL )
	+int1d(th,bcwall)(u#x*v#x*TGVCL)
	-int1d(th,bcwall)(TGVCL*(U0*v#y)*(formulation=="A") )

	+ on(bcaxis,u#x=0.0,u#p=0.0) /*Mode antisymetric, valid for both formulations*/
//EOM
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
macro BoundaryconditionsLNSE(u,v,formulation)/*For the free movement problem*/
	int1d(th,bcinlet,bclat)(u#y*v#y*TGVCL*(formulation=="A") )
	+int1d(th,bcinlet,bclat)(u#y*v#y*TGVCL*(formulation=="R") ) /* + le terme BBB de interaction sur Avf*/
	/* +int1d(th,bcinlet,bclat)(u#x*v#x*TGVCL)useless if domain is big enough:sometimes it introduces errors
	+int1d(th,bcinlet,bclat)(u#p*q*TGVCL)*/

	+int1d(th,bcwall)(u#y*v#y*TGVCL*(formulation=="A") ) /* + le terme AAA de interaction sur Avf*/
	+int1d(th,bcwall)(u#y*v#y*TGVCL*(formulation=="R") )
	+int1d(th,bcwall)(u#x*v#x*TGVCL) 

	+int1d(th,bcaxis)(u#x*v#x*TGVCL);/*Valid for the 2 formulations*/
	/*+int1d(th,bcaxis)(u#p*q*TGVCL);don't need*/
//EOM

////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
// HERE ARE SOME MACROS WHICH ARE USEFUL FOR POST-PROCESSING WITH A 2D FLOW OVER A BLUFF BODY
/*bclat=4,bcinlet=1,bcoutflow=3,bcwall=2,bcaxis=6*/

macro TraineeP(u,symmetry)
	int1d(th,2,21,22,23)(
	( 1*(symmetry=="N") + 2*(symmetry=="S") )
	*u#p*N.x
	)
//EOM
macro TraineeV(u,symmetry)
	-int1d(th,2,21,22,23)(
	( 1*(symmetry=="N") + 2*(symmetry=="S") )
        *2*nu*( [1,0]'*(Dbis(u)*[N.x,N.y])  )
	)
//EOM
macro Trainee(u,symmetry)
	TraineeP(u,symmetry)+TraineeV(u,symmetry)
//EOM
macro Portance(u,symmetry)
	int1d(th,2,21,22,23)(
	( 1*(symmetry=="N") + 2*(symmetry=="A") )
	*u#p*N.y
	)        
	-int1d(th,2,21,22,23)(
	( 1*(symmetry=="N") + 2*(symmetry=="A") )
        *2*nu*( [0,1]'*(Dbis(u)*[N.x,N.y])  )
	)
//EOM
macro PortanceTEST(u,symmetry)   
	int1d(th,2,21,22,23)(u#p*N.y*  (1*(symmetry=="N")+2*(symmetry=="A"))   )
	-int1d(th,2,21,22,23)(nu*2*dy(u#y)*N.y*(1*(symmetry=="N")+2*(symmetry=="A"))+nu*(dx(u#y)+dy(u#x))*N.x*(1*(symmetry=="N")+2*(symmetry=="A")))
	
//EOM
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
//...
macro SFWriteMesh(filename,TH)
{
     ofstream fileFF(filename);
     fileFF << "### MESH generated by Freefem++ ; " << endl;
     fileFF << "2D mesh" << endl;
     fileFF << "Format :" << endl;
	 fileFF << "int np int Ndof real deltamin real deltamax" ;
	 string PostProcessMeshDescription = " real deltaA real deltaB real deltaC real deltaD" ; /*description of customizable part*/
	 fileFF << PostProcessMeshDescription << endl << endl ;
     fespace femp1N(TH,P1);
     fespace femp2xfemp2xfemp1N(TH,[P2,P2,P1]);	  
     femp2xfemp2xfemp1N [uNx,uNy,uNp];
	 fileFF << TH.nv <<  endl << uNx[].n << endl ;
 	 cout << "#### Mesh information :" << endl;  
     cout << "## Number of vertices    " << TH.nv <<  endl;
	 cout << "## Number of DOF : " << uNx[].n << endl << endl;  
 	 femp1N delta = hTriangle;
	cout << "## delta min : " << delta[].min << endl;
	cout << "## delta max : " << delta[].max << endl;
	fileFF << delta[].min << endl;
	fileFF << delta[].max << endl;   
    /*Next is customizable part ; here determination of the grid size at several points */
    real[int] xprobe = [0,	2.5,	4,	10];
    real[int] yprobe = [.5, 	.5,	0,	0]; 
	cout << "## delta(0,.5) : ( boundary layer) : " << delta(xprobe(0),yprobe(0)) << endl ;
	cout << "## delta(2.5,.5) : ( sensitivity) : " << delta(xprobe(1),yprobe(1)) << endl ;
	cout << "## delta(4,0) : ( wake ) : " << delta(xprobe(2),yprobe(2)) << endl << endl ;
    cout << "## delta(10,0) : ( far wake ) : " << delta(xprobe(3),yprobe(3)) << endl << endl ;
	for(int ii = 0; ii<4;ii++){ fileFF << delta(xprobe(ii),yprobe(ii)) << endl ;}	
 
}; 	 
//EOM
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
//...
macro SFWriteBaseFlow(filename,u,typeFlow,iter)
	if(iter>=0)
	{
	fespace p1forff2m(th,P1);  
	p1forff2m xx,yy;
	xx=x;
	yy=y;
    p1forff2m ut,vt,pt,vort;
	ut=u#x;
	vt=u#y;
	pt=u#p;
	vort=dy(u#x)-dx(u#y); /* vorticity */
	p1forff2m psi,phi;
/*	solve Laplace(psi,phi, solver = CG) */
/* 	= int2d(th)(dx(psi)*dx(phi)+dy(psi)*dy(phi)) */
/* 	- int2d(th)(-vort*phi) */
/* 	- int1d(th,bcinlet,bcoutflow,bclat,bcwall)((-N.x*ux+N.y*uy)*phi); */   
	ofstream file(filename);
   	{
	file << "### Data generated by Freefem++ ; " << endl;
    file << typeFlow << endl;
    file << "Format : " << endl;	
	file << "real Re P1 ux P1 uy P1 p P1 vort P1 psi real iter " ;
	string PostProcessBaseFlowDescription = "real Cx real Lx"; /* customizable output */ 
	file << PostProcessBaseFlowDescription << endl << endl ; 
	file << Re << endl;	
			for (int j=0;j<ut[].n ; j++) file << ut[][j] << endl;
			for (int j=0;j<ut[].n ; j++) file << vt[][j] << endl;
			for (int j=0;j<ut[].n ; j++) file << pt[][j] << endl;
			for (int j=0;j<ut[].n ; j++) file << vort[][j] << endl;
			for (int j=0;j<ut[].n ; j++) file << psi[][j] << endl;
			file << iter << endl;
	
	cout << "#### customisable output for WAKE OF A 2D BLUFF BODY : " << endl; 
    /* Calcul de la trainee */
    real DragMode = Trainee(u,symmetryBaseFlow);
	cout << "#    Cx =  " << 2*DragMode << endl; /* factor 2 because Fx = 1/2 Cx */
    file << 2*DragMode << " " ; 
    real Lx, Uap, Uav;
    if(iter>0)
    {
    /* mesure de la longueur de recirculation */
		{
		real dx = 0.001;real Uav = -2e-10;real Uap=-1e-10;int ix;
			for(ix=1;ix<20000;ix++)
			{   
				Uap =u#x(0.5+ix*dx,0);
				if(Uap*Uav<0){break;};
				Uav = Uap;	
			}
			real xav = 0.5+(ix-1)*dx; 
			real xap = 0.5+ix*dx;
			Lx = xav *(Uap)/(Uap-Uav) + xap *(-Uav)/(Uap-Uav);
		}	
    }
    else
    { 
    	Lx = 0;
    };
    cout << "#    Recirculation length = " << Lx << endl << endl; 
		file << Lx << endl;
     
	}
	}
	else
	{
	ofstream file(filename);
	file << "### Data generated by Freefem++ ; " << endl;
    file << "BaseFlow NOT CONVERGED" << endl;
    file << "Format : " << endl;	
	file << "int iter " << endl;
	file << -1 << endl;
	};
//EOM
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////	
macro SFWriteMode(namefile,u,ev,shift,typeFlow,iter)
{
        ofstream file(namefile);
   	fespace p1forff2m(th,P1); 
	p1forff2m xx,yy;
	xx=x;
	yy=y;
    	p1forff2m<complex> ux1,uy1,pp1,vort1, NORM;  		 
 	file << "### Data generated by Freefem++ ; " << endl;
    	file << typeFlow << endl;
    	file << "Format :" << endl;
    	string descriptionFF;
	/*if(typeFlow=="EigenModeD"||typeFlow=="HarmonicMode")
    	 	{  descriptionFF="real Re complex lambda complex shift int iter P1c ux1 P1c uy1 P1c p1 P1c vort1 real AEnergy complex Fy"; }*/ /*IL MANQUE LES OUTRES, VOIR STAB2D*/
	if(typeFlow=="VIVModeD"||typeFlow=="HarmonicMode")  /*fazer um viv adjoint*/
		{ descriptionFF="real Re complex lambda complex shift int iter P1c ux1 P1c uy1 P1c p1 P1c vort1 real AEnergy complex Cy complex Y complex V complex A"; }
	else if(typeFlow=="VIVModeA")
 		{  descriptionFF="real Re complex lambda complex shift int iter P1c ux1Adj P1c uy1Adj P1c p1Adj P1c vort1Adj real AEnergyAdj complex CyAdj complex YAdj complex VAdj complex AAdj"; }
	file << descriptionFF << endl << endl ; 
	file << Re  << endl << real(ev) << " " << imag(ev) << " " << real(shift) << " " << imag(shift) << " " << iter << endl << endl;
	ux1=u#x;
	uy1=u#y;
	pp1=u#p;
	vort1=dy(u#x)-dx(u#y);
		
	for (int j=0;j<ux1[].n ; j++) file << real(ux1[][j]) << " " << imag(ux1[][j]) << endl;
	for (int j=0;j<ux1[].n ; j++) file << real(uy1[][j]) << " " << imag(uy1[][j]) << endl;
	for (int j=0;j<ux1[].n ; j++) file << real(pp1[][j]) << " " << imag(pp1[][j]) << endl;
	for (int j=0;j<ux1[].n ; j++) file << real(vort1[][j]) << " " << imag(vort1[][j]) << endl;
		
	cout << "#### customisable output for a mode in the WAKE OF A 2D BLUFF BODY : " << endl; 

	
	real AEnergyMode = sqrt(2*int2d(th)(abs(u#x)^2+abs(u#y)^2)); 
	cout << "#   Amplitude (with definition of Mantic-Lugo) = " << AEnergyMode << endl;
	file << AEnergyMode << endl;

	complex LiftMode = Portance(u,"A"); 
	cout << "#   Cy = " << 2*LiftMode << endl;
	file << 2*real(LiftMode) << " " << 2*imag(LiftMode) << endl;
};
//EOM	
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

macro SFWriteModeVIV(namefile,mode,ev,shift,typeFlow,iter)
{
	SFWriteMode(namefile,mode,ev,shift,typeFlow,iter);
	ofstream file(namefile,append);
	file << real(mode#Y) << " " << imag(mode#Y) << endl;
	file << real(mode#V) << " " << imag(mode#V) << endl;
	file << real(mode#A) << " " << imag(mode#A) << endl;
	/*debug style: */
	cout <<  " real(Y): "<< real(mode#Y) << " imag(Y): " << imag(mode#Y) << endl;
	cout <<  " real(V): "<< real(mode#V) << " imag(V): " << imag(mode#V) << endl;
	cout <<  " real(A): "<< real(mode#A) << " imag(A): " << imag(mode#A) << endl;
};
//EOM	
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
macro WriteOutputFiles(EVCalculated,shift,mode,EMCalculated,typeDA,nev,iter)
{
	string namefile;
	namefile=ffdatadir+"Spectrum.txt";
	ofstream fileVP1(namefile); /*This overwrites the previously done*/
	
	for (int i=0;i<nev;i++)
	{
		fileVP1 << real(EVCalculated[i]) << " " << imag(EVCalculated[i]) << " " << Re << " " << real(shift) << " " << imag(shift) << endl;
		cout << "Eigenvalue: " << i+1 << "  : " << EVCalculated[i] << endl;
	
		[mode#x[],mode#Y,mode#V,mode#A] = EMCalculated(:,i);
		/*Two files: a txt file and a ff2m file*/

		if(typeDA=="D"&&nev>1){namefile=ffdatadir+"Eigenmode"+(i+1);}
		if(typeDA=="D"&&nev==1){namefile=ffdatadir+"Eigenmode";}
		if( (typeDA=="A"||typeDA=="cA") &&nev>1){namefile=ffdatadir+"EigenmodeA"+(i+1);}
		if( (typeDA=="A"||typeDA=="cA") &&nev==1){namefile=ffdatadir+"EigenmodeA";}
		{ofstream fileMode(namefile+".txt");
 		 fileMode << mode#x[]<< endl;  
		 fileMode << endl << mode#Y << " " << mode#V << " " << mode#A << endl; 
 		 fileMode << endl << endl << Re << endl << endl << real(EVCalculated[i]) << "   " << imag(EVCalculated[i])  << endl;
 		}
		cout << "Writing eigenmode in .ff2m file: " << namefile << endl;
		if(typeDA=="D"){SFWriteModeVIV(namefile+".ff2m",mode,EVCalculated[i],shift,"VIVModeD",iter);}
		if( (typeDA=="A"||typeDA=="cA") ){SFWriteModeVIV(namefile+".ff2m",mode,EVCalculated[i],shift,"VIVModeA",iter);}
	};
	cout << "Writing Output Files Done" << endl;
}
//EOM	
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
macro ShiftAndInvertVIV(OP,B,u0,b0,mode,EVCalculated,shiftOP,sigma0,err)
{
	complex[int] X0 = [u0#x[],b0#Y,b0#V,b0#A];
	complex[int] rhs= B*X0;  /*rhs=Right Hand Side*/
	/* step1*/
	complex[int] X = OP^-1*rhs;
	[mode#x[],mode#Y,mode#V,mode#A] = X; 
cout << "Composantes solide du mode : " << mode#Y << " ; " << mode#V << " ; " << mode#A << endl;
	/*step2*/
	complex XnXn1 = int2d(th)(u0#x*mode#x+u0#y*mode#y) + b0#Y*mode#Y + b0#V*mode#V + b0#A*mode#A;
	complex Xn1Xn1 =  int2d(th)(mode#x*mode#x+mode#y*mode#y) + mode#Y*mode#Y + mode#V*mode#V   + mode#A*mode#A;
	complex GG = Xn1Xn1/XnXn1;
	/*at each iter the inverse shifted eigenval. is approximated by <X_{n+1}, Y> / <X_n, Y>;      ( the choice Y = X_{n+1} is convenient but we could choose something else )*/
	EVCalculated = shiftOP+1/GG;

	err = abs(EVCalculated-sigma0);	
	/*step3*/
	u0#x[] = (1./sqrt(abs(Xn1Xn1)))*mode#x[];
	b0#Y = (1./sqrt(abs(Xn1Xn1)))*mode#Y;		
	b0#V = (1./sqrt(abs(Xn1Xn1)))*mode#V;
	b0#A = (1./sqrt(abs(Xn1Xn1)))*mode#A;
	sigma0 = EVCalculated;
}
//EOM	
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
macro ShiftAndInvertFAIL
{
	cout << " ERROR : shift-invert iteration failed ; shift is probably wrong" << endl;
	/*exec("rm Eigenmode.txt");
	exec("rm EigenmodeA.txt");
	exec("rm Eigenmode.ff2m");
	exec("rm EigenmodeA.ff2m");*/
	{
	string namefileFF=ffdatadir+"Eigenmode.ff2m";
	ofstream fileFF(namefileFF);
	fileFF << "### Data generated by Freefem++ ; " << endl;
	fileFF << "EIGENMODE for a 2D flow" << endl;
	fileFF << "Format :" << endl;
	fileFF << "int iter" << endl << endl ; 
	fileFF << -1 << endl;
	}
	exec("cp "+ffdatadir+"Eigenmode.ff2m " +ffdatadir+"EigenmodeA.ff2m");
	{
	ofstream file(ffdatadir+"Eigenvalue.txt");
	file << " 0 0 0 0 0 " << endl;
	}
	exec("cp "+ffdatadir+"Eigenmode.txt " +ffdatadir+"EigenmodeA.txt");
}
//EOM	
////////////////////////////////////////////////////////////////////////////////////////////
//END EDP FILE
	
