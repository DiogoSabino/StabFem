
string ffdatadir = "./";

IFMACRO(!problemtype)
macro problemtype "2D"//EOM
ENDIFMACRO
	
macro SFWriteMode(namefile,u,k,Z)
		 {
		 ofstream file(namefile);
   		 fespace p1forff2m(th,P1); 
		 p1forff2m xx,yy;
		 xx=x;
		 yy=y;
    	 p1forff2m<complex> phiC;
    	  
    	/*  field on the axis */ 
    	VH<complex> pp = 1i*k*f;
        VH<complex> u = dy(f);
        int Naxis = 501;
        complex[int] ppaxis(Naxis),uaxis(Naxis);
        real[int] Xaxis(Naxis);
        int index=0;
        for(real zz=yy[].min; zz<yy[].max; zz=zz+ (yy[].max-yy[].min)/500)
        {
        ppaxis(index) = pp(0,zz); 
        uaxis(index) = u(0,zz);
        Xaxis(index) =zz;
        index++; 
        }
        Naxis = index; 	  		 
 		 file << "### Data generated by Freefem++ ; " << endl;
    	 file << "AcousticField" << endl;
    	 file << "Format :" << endl;
    	 string descriptionFF;
    	 descriptionFF="real k complex Z P1c Phi "; 
    	 descriptionFF=descriptionFF + " real."+Naxis+" Xaxis " + " complex."+Naxis+" Paxis "
    	                             + " complex."+Naxis+" Uaxis "; 
	     file << descriptionFF << endl << endl ; 
		 file << k  << endl << real(Z) << " " << imag(Z) << endl;
		phiC=u;
		for (int j=0;j<phiC[].n ; j++) 
        {
            file << real(phiC[][j]) << " " << imag(phiC[][j]) << endl;
		};
		file << endl;
		for(int j=0;j<Naxis;j++) { file << Xaxis(j) << endl;};
		for(int j=0;j<Naxis;j++) { file << real(ppaxis(j)) << " " << imag(ppaxis(j)) << endl;};
		for(int j=0;j<Naxis;j++) { file << real(uaxis(j)) << " " << imag(uaxis(j)) << endl;};
        }
        
//EOM	



macro SFWriteBaseFlow(filename)


	ofstream file(filename);
   	{
	file << "### Data generated by Freefem++ ; " << endl;
    file << "BaseFlow" << endl;
    file << "Format : " << endl;	
    file << "real ZERO" << endl;
    file << 0 << endl;
	};
//EOM
	


macro SFWriteMesh(filename,TH)
{
     ofstream fileFF(filename);
     fileFF << "### MESH generated by Freefem++ ; " << endl;
     fileFF << "2D mesh" << endl;
     fileFF << "Format :" << endl;
	 fileFF << "int np int Ndof real deltamin real deltamax" ;
	 string PostProcessMeshDescription = " real deltaA real deltaB real deltaC real deltaD" ; /*description of customizable part*/
	 fileFF << PostProcessMeshDescription << endl << endl ;
     fespace femp1N(TH,P1);
     fespace femp2xfemp2xfemp1N(TH,[P2,P2,P1]);	  
     femp2xfemp2xfemp1N [uNx,uNy,uNp];
	 fileFF << TH.nv <<  endl << uNx[].n << endl ;
 	 cout << "#### Mesh information :" << endl;  
     cout << "## Number of vertices    " << TH.nv <<  endl;
	 cout << "## Number of DOF : " << uNx[].n << endl << endl;  
 	 femp1N delta = hTriangle;
	cout << "## delta min : " << delta[].min << endl;
	cout << "## delta max : " << delta[].max << endl;
	fileFF << delta[].min << endl;
	fileFF << delta[].max << endl;   
    /*Next is customizable part ; here determination of the grid size at several points */
    real[int] xprobe = [0,	2.5,	4,	10];
    real[int] yprobe = [.5, 	.5,	0,	0]; 
	cout << "## delta(0,.5) : ( boundary layer) : " << delta(xprobe(0),yprobe(0)) << endl ;
	cout << "## delta(2.5,.5) : ( sensitivity) : " << delta(xprobe(1),yprobe(1)) << endl ;
	cout << "## delta(4,0) : ( wake ) : " << delta(xprobe(2),yprobe(2)) << endl << endl ;
    cout << "## delta(10,0) : ( far wake ) : " << delta(xprobe(3),yprobe(3)) << endl << endl ;
	for(int ii = 0; ii<4;ii++){ fileFF << delta(xprobe(ii),yprobe(ii)) << endl ;}	
 
}; 	 
//EOM
