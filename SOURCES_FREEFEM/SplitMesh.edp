//
//  PROGRAM SplitMesh.edp
//  adaptmesh for 2D flow 
//   
// Usage : FreeFem++ SplitMesh.edp 
//
//  INPUT PARAMETERS : none

//
//	INPUT FILES :
// 		mesh.msh ->  mesh in Freefem format
//		BaseFlow.txt	-> guess base flow (generated by mesh generator, time integration or previous Newton)
//  OUTPUT FILES :
//		mesh.msh -> New mesh
//		BaseFlow_guess.txt -> BaseFlow interpolated on new mesh (guess for next Newton)		
//		mesh_ans.msh, BaseFlow_ans.txt -> previous mesh and base flow to allow reconstruction in case adaptmesh was not successful 
// 		nb : BaseFlow.txt is removed, to force new computation with Newton

// 	ERROR MANAGEMENT : 
//
//  D. Fabre et al., June 2017
//




	verbosity = 0;
	include "Macros_StabFem.edp";
	

	exec("cp "+ffdatadir+"mesh.msh "+ffdatadir+"mesh_ans.msh");
	exec("cp "+ffdatadir+"mesh.ff2m "+ffdatadir+"mesh_ans.ff2m");
	exec("cp "+ffdatadir+"BaseFlow.txt "+ffdatadir+"BaseFlow_ans.txt");
	exec("cp "+ffdatadir+"BaseFlow.ff2m "+ffdatadir+"BaseFlow_ans.ff2m");

	 
	mesh th=readmesh(ffdatadir+"mesh.msh");
	mesh thold = th;
	int nvprev = th.nv;
	    
	    fespace femp2(th,P2);   
        fespace femp1(th,P1);
        fespace femp0(th,P0);
        fespace femp2xfemp2xfemp1(th,[P2,P2,P1]);
        fespace femp2xfemp2xfemp2xfemp1(th,[P2,P2,P2,P1]);
        femp2xfemp2xfemp1 [vB,uB,pB]; // base flow
        femp2xfemp2xfemp2xfemp1 [vBS,uBS,wBS,pBS]; // base flow
        	
	cout << "###################################" << endl;
cout << endl << "       Adapt_Mode.edp        " << endl; 
cout << endl << "###################################" << endl << endl;
	

cout << endl << "#### Mesh information BEFORE ADAPT :" << endl;  
        cout << "#### Number of vertices    " << th.nv <<  endl;
	    cout << "### Dimension of matrices " << vB[].n << endl << endl;
	
	real Re;
	
	
	
/// LECTURE BASE FLOW	
	    
	    int NdimUVP = uB[].n;
    	int NdimUVWP = uBS[].n;
    	int NdimBaseFlow;
    	real Reans;
	    {
          ifstream file(ffdatadir+"BaseFlow.txt");
          file >> NdimBaseFlow ;
          file >> Reans;
    	}
		Re = Reans;
		
		if(NdimBaseFlow == NdimUVP) 
		{
        cout << "Ndim = " << NdimUVP << " : reading UVP baseflow " << endl;
        ifstream file(ffdatadir+"BaseFlow.txt");
        file >> uB[];
        [vBS,uBS,wBS,pBS] = [vB,uB,0,pB];
		file >> Reans;
        }
        else if(NdimBaseFlow == NdimUVWP) 
        {
        cout << "Ndim = " << NdimUVWP << " : reading UVWP baseflow " << endl;
        ifstream file(ffdatadir+"BaseFlow.txt");
        file >> uBS[]; 
		file >> Reans;
        }
        else 
        {
        cout << " Error : Wrong dimension For BaseFlow_guess.txt file" << endl;
        };

	
	
    cout << " lecture of Base flow : Reynolds number = " << Re << endl;

	mesh thnew;	
	
	
// selection of the type of adaptation to be done 
	
	thnew = splitmesh(th,2);	
		
	plot(thold,wait=1);
	plot(thnew,wait=1);
	
	savemesh(thnew,ffdatadir+"mesh.msh");
	SFWriteMesh(ffdatadir+"mesh_adapt.ff2m",thnew);


	
// INTERPOLATE BASE FLOW ON NEW MESH AND WRITE TO FILE
    fespace femp2N(thnew,P2);   
    fespace femp1N(thnew,P1);
    fespace femp0N(thnew,P0);
 	fespace femp2xfemp2xfemp1N(thnew,[P2,P2,P1]);
 	fespace femp2xfemp2xfemp2xfemp1N(thnew,[P2,P2,P2,P1]);
    femp2xfemp2xfemp1N [uNx,uNy,uNp];
  
    [uNx,uNy,uNp] = [vB,uB,pB]; // interpolation of base flow
//	plot(uBN,fill=1,wait=1);
//	plot(vBN,fill=1,wait=1);
//	plot(pBN,fill=1,wait=1);

	Re = Reans;
	real nu = 1/Re;
    {
		ofstream U(ffdatadir+"BaseFlow_guess.txt");		
        U << uNx[];
        U << endl << endl <<  Re << endl;
    }

// hack    
    IFMACRO(problemtype,"2D")
	 SFWriteBaseFlow(ffdatadir+"BaseFlow.ff2m",uN,"BaseFlow",1);
	ENDIFMACRO

	IFMACRO(problemtype,"AxiXR")
	femp2xfemp2xfemp1N [uNNx,uNNr,uNNp];
    [uNNx,uNNr,uNNp] = [vB,uB,pB];
	SFWriteBaseFlow(ffdatadir+"BaseFlow.ff2m",uNN,"BaseFlow",1);
	ENDIFMACRO
// end of hack : this is because SFWriteBaseFlow expects different component names for 2D and axi cases !


// INTERPOLATE THE DATA AND WRITE TO FILE

 




